import re
import os
from configparser import SafeConfigParser
fname="dff.v"
read_file = open('connection_info.txt', 'r')
data = read_file.readlines()

input_list=[]
output_list=[]
for line in data:
    if re.match(r'^\s*$', line):
        pass
    else:
        in_items = re.findall(
            "INPUT", line, re.MULTILINE | re.IGNORECASE
        )
        out_items = re.findall(
            "OUTPUT", line, re.MULTILINE | re.IGNORECASE
        )
    if in_items:
        input_list.append(line.split())
    if out_items:
        output_list.append(line.split())
input_port = []
output_port = []
home='sumanto'
# creating list of input and output port with its weight
for input in input_list:
    input_port.append(input[0]+":"+input[2])
for output in output_list:
    output_port.append(output[0]+":"+output[2])
 ############## Creating content for cfunc.mod file ############## #

print("Starting With cfunc.mod file")
csim = open('sim_main.cpp', 'w')
print("Building content for cfunc.mod file")

comment = '''/* This is cfunc.mod file auto generated by gen_con_info.py
Developed by Sumanto Kar at IIT Bombay */\n
'''

header = '''
#include <memory>
#include <verilated.h>
#include "V'''+fname.split('.')[0]+'''.h"
#include <stdio.h>
#include <stdio.h>
#include <fstream>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <cstring>
using namespace std;
'''

extern_var = []
for i,item in enumerate(input_port+output_port):
    extern_var.append('''
extern "C" int temp_''' +item.split(':')[0]+'''[1024];
extern "C" int port_''' +item.split(':')[0]+''';''')


extern_var.append('''
extern "C" int foo(int,int);
''')
convert_func='''
void int2arr(int  num, int array[], int n)
{   
    for (int i = 0; i < n && num>=0; i++) 
    {
        array[i] = num % 10;
        num /= 10;
        }
}
int arr2int(int array[],int n)
{   
    int i,k=0;
    for (i = 0; i < n; i++) 
        k = 10 * k + array[i];
    return k;
}
'''
foo_func = '''
int foo(int init,int count) 
{
    static VerilatedContext* contextp = new VerilatedContext;
    static V'''+fname.split('.')[0]+"* "+fname.split('.')[0]+'''[1024];
    count--;
    if (init==0) 
    {
        '''+fname.split('.')[0]+'''[count]=new V'''+fname.split('.')[0]+'''{contextp};
        contextp->traceEverOn(true);
    }
    else
    {
        contextp->timeInc(1);
        printf("=============New Iteration===========");
        printf("\\nInside foo before eval.....\\n");
'''


before_eval=[]
after_eval=[]
for i,item in enumerate(input_port+output_port):   
    before_eval.append('''\t\tprintf("'''+\
        item.split(':')[0]+'''=%d\\n", '''+fname.split('.')[0]+'''[count] ->'''+item.split(':')[0]+''');\n''')
for i,item in enumerate(input_port):
    
    before_eval.append('''\t\t'''+\
        fname.split('.')[0]+'''[count]->'''+item.split(':')[0]+''' = arr2int(temp_'''+item.split(':')[0]+", port_"+item.split(':')[0]+''');\n''')
before_eval.append("\t\t"+fname.split('.')[0]+"->eval();\n");


after_eval.append('''
        printf("\\nInside foo after eval.....\\n");\n''')
for i,item in enumerate(input_port+output_port):
    after_eval.append('''\t\tprintf("'''+item.split(':')[0]+'''=%d\\n", '''+fname.split('.')[0]+'''[count] ->'''+item.split(':')[0]+''');\n''')
    
for i,item in enumerate(output_port):   
    after_eval.append("\t\tint2arr("+fname.split('.')[0]+'''[count] -> '''+\
        item.split(':')[0]+''', temp_'''+item.split(':')[0]+''', port_'''+item.split(':')[0]+''');\n''')
after_eval.append('''
    }
    return 0
}''')


csim.write(comment)
csim.write(header)
for item in extern_var:
    csim.write(item)
csim.write(convert_func)
csim.write(foo_func)

for item in before_eval:
    csim.write(item)
for item in after_eval:
    csim.write(item)
